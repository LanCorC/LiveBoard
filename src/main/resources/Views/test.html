<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            height: 100vh;
            width: 100vw;
            margin: 0;
            display: block;
            overflow: hidden;
/*            background-image: url(../Images/sticky-note-with-postponed-messageFreePikDotCom.jpg);*/
        }
        #gameBoard {
            background-position: center;
            background-color: white;
            background-image: none;
        }
    </style>
</head>
<body id="viewport">
<canvas id="gameBoard"></canvas>
</body>
<script>
    //Variables
    const board = document.getElementById("gameBoard");
    const background = new Image();
    console.log("please call me back");

    window.onload = function() {
        console.log("beep!");
        board.height = window.innerHeight;
        board.width = window.innerWidth;


        //Load all event interactions, draws,
        const context = board.getContext("2d");
        trackTransforms(context);


        const redraw = function() {
            //Clear
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0,0,board.width,board.height);
            context.restore();

            //Repaint
            context.drawImage(background, 0, 0);
            console.log("redrawn!");
        }
        redraw();

        //mouse tracking
        let mouse = {
            x: board.width,
            y: board.height
        };

        let startPoint;
        let dragging;

        board.addEventListener("mousemove", function(event) {
            mouse.x = event.offsetX;
            mouse.y = event.offsetY;
            //check for click-hold-drag
            if(startPoint) {
                let pt = context.transformPoint(mouse.x, mouse.y);
                context.translate(pt.x-startPoint.x, pt.y-startPoint.y);
                redraw();
            }
        },false);

        //TODO: check 2ndary canvas if 'playmat' or 'tabletop' selected, as opposed to 'card' or 'deck'
        board.addEventListener("mousedown", function() {
            startPoint = context.transformPoint(mouse.x, mouse.y);
            dragging = true;
        }, false);
        board.addEventListener("mouseup", function() {
            startPoint = null;
            dragging = false;
        }, false);


        //experimental rotate the entire board
        //in appropriate application, tie this to a button - works
        //cons: rotates from 0,0 and does is document global for keypress a,d
        window.addEventListener("keydown", function(event){
            let key = event.code;
            console.log(key);
            if(key == "KeyA") {
                console.log("a");
                context.rotate(15 * Math.PI / 180);
            } else if(key == "KeyD") {
                context.rotate(-15 * Math.PI / 180);
                console.log("d");
            }
            redraw();
        }, false);

        //scroll responsiveness multiplier
        let scale = 1.1;

        const zoom = function(val) {
            let factor = Math.pow(scale, val); //example: scale '2' results in => double (pow2) or half (pow-2 = x0.5)
            let pt = context.transformPoint(mouse.x, mouse.y);
            context.translate(pt.x, pt.y);
            context.scale(factor, factor);
            context.translate(-pt.x, -pt.y);
            redraw();
        }

        const scroll = function(event) {
            event.preventDefault();

            //Positive deltaY is scrolling down, or 'zooming out', thus smaller scale
            zoom(event.deltaY < 0 ? 1 : -1);
        }

        //Event is registering
        //        board.addEventListener("wheel", (event) => { console.log("wheel") } );
        board.addEventListener("wheel", scroll, false);


        //Window resizing -- works
        //this is something to import, so it does not clog; like a library
        window.addEventListener('resize', function(event) {
            const vp = document.getElementById("viewport");
            vp.style.height = '100vh';
            vp.style.width = '100vw';
            board.height = window.innerHeight;
            board.width = window.innerWidth;
            console.log("resized");
            redraw();
        }, true);
    }

    background.src = "../Images/sticky-note-with-postponed-messageFreePikDotCom.jpg";

    //transformTracking; for now is single for transforming the point
    //TODO: maybe bind BOTH canvases here. where one is transformed, called to redraw, so it the other
    function trackTransforms(ctx) {
        //has transform properties
//        let matrix = DOMMatrix();

//        let transforms = []; //stores transforms, for purpose of save() and restore()

//        let save = ctx.save;
//        ctx.save = function() {
//            transforms.push(matrix);
//
//
//            return save.call(ctx);
//        }

        //Assuming this is all i minimally require for single-canvas
        let point = new DOMPoint();
        ctx.transformPoint = function(x, y) {
            point.x = x; point.y = y;
            let matrix = ctx.getTransform();
            //converts on-screen client.x,client.y to true canvas position (post transform)
            return point.matrixTransform(matrix.inverse());
        }
    }

</script>
</html>